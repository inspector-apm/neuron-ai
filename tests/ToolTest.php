<?php

namespace NeuronAI\Tests;

use NeuronAI\Tests\stubs\Color;
use NeuronAI\Tests\stubs\ColorMapperToolStub;
use NeuronAI\Tests\stubs\DivideToolStub;
use NeuronAI\Tools\ObjectProperty;
use NeuronAI\Tools\PropertyType;
use NeuronAI\Tools\ToolProperty;
use NeuronAI\Tools\Tool;
use NeuronAI\Tools\ToolInterface;
use PHPUnit\Framework\TestCase;

class ToolTest extends TestCase
{
    public function test_tool_instance()
    {
        $tool = new Tool('example', 'example');
        $this->assertInstanceOf(ToolInterface::class, $tool);

        $tool->setInputs(null);
        $this->assertEquals([], $tool->getInputs());

        $tool->setCallId(null); // Tool call ID is not generated by all providers
        $this->assertEquals(null, $tool->getCallId());
        $tool->setCallId('test');
        $this->assertEquals('test', $tool->getCallId());
    }

    public function test_required_properties()
    {
        $tool = Tool::make('test', 'Test tool')
            ->addProperty(
                new ToolProperty('name', PropertyType::STRING, 'User name', true)
            )
            ->addProperty(
                new ToolProperty('surname', PropertyType::STRING, 'User surname', false)
            )
            ->addProperty(
                new ToolProperty('age', PropertyType::INTEGER, 'User age', true)
            )
            ->setCallable(function (): void {
            });

        $properties = $tool->getRequiredProperties();
        $this->assertEquals(['name', 'age'], $properties);
    }

    public function test_required_properties_with_mapped_object()
    {
        $tool = Tool::make('test', 'Test tool')
            ->addProperty(
                new ObjectProperty(
                    name: 'name',
                    description: 'User name',
                    required: true,
                    class: Color::class
                )
            )
            ->setCallable(function (): void {
            });

        $toolRequiredProperties = $tool->getRequiredProperties();
        $objRequiredProperties = $tool->getProperties()[0]->getRequiredProperties();
        $this->assertEquals(['name'], $toolRequiredProperties);
        $this->assertEquals(['r', 'g', 'b'], $objRequiredProperties);
    }

    public function test_tool_return_value()
    {
        $tool = Tool::make('test', 'Test tool');

        $tool->setCallable(fn () => 'test')->execute();
        $this->assertEquals('test', $tool->getResult());

        $tool->setCallable(fn () => ['test'])->execute();
        $this->assertEquals('["test"]', $tool->getResult());

        $tool->setCallable(fn () => ['foo' => 'bar'])->execute();
        $this->assertEquals('{"foo":"bar"}', $tool->getResult());

        $tool->setCallable(fn () => new class () {
            public function __toString(): string
            {
                return 'test';
            }
        })->execute();
        $this->assertEquals('test', $tool->getResult());
    }

    public function test_tool_with_invoke_and_primitives_params()
    {
        $divideTool = new DivideToolStub();

        $divideTool->setInputs([
            'a' => 5,
            'b' => 5
        ]);

        $divideTool->execute();

        $this->assertEquals(1, $divideTool->getResult());
    }

    public function test_tool_with_invoke_and_object_params()
    {
        $colorTool = new ColorMapperToolStub();

        // Object param already as an object. In reality, this case should never happen..
        $colorTool->setInputs([
            'color' => new Color(1, 0, 0)
        ]);

        $colorTool->execute();

        $this->assertEquals("red", $colorTool->getResult());

        // Object param as an associative array
        $raw = '{"r": 1, "g": 0, "b": 0}';

        // In fact, json string is decoded by the provider during chat handling
        $arrayObject = json_decode($raw, true);

        $colorTool->setInputs([
            'color' => $arrayObject
        ]);

        $colorTool->execute();
        $this->assertEquals("red", $colorTool->getResult());


        // What if the provided params doesn't respect the expected schema, a validation through validation rules ?
        $raw = '{}';
        $arrayObject = json_decode($raw, true);

        $colorTool->setInputs([
            'color' => $arrayObject
        ]);

        $colorTool->execute();

        $this->assertEquals(
            "# CRITICAL"
            .PHP_EOL
            ."There was a problem with the provided inputs that generated the following violations:"
            .PHP_EOL
            ."- **color**: r must not be null, g must not be null, b must not be null"
            .PHP_EOL
            ."# TOOL USAGE"
            .PHP_EOL
            ."- When using tools, provide ONLY valid JSON parameters"
            .PHP_EOL
            ."- The JSON must be pure, perfectly valid and deserializable",
            $colorTool->getResult()
        );
    }

    public function test_invalid_return_type()
    {
        $tool = Tool::make('test', 'Test tool');

        $this->expectException(\TypeError::class);

        $tool->setCallable(fn () => new class () {
        })->execute();
    }
}
